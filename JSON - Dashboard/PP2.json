{
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": true,
        "iconColor": "rgba(0, 211, 255, 1)",
        "name": "Annotations & Alerts",
        "type": "dashboard"
      }
    ]
  },
  "editable": true,
  "fiscalYearStartMonth": 0,
  "graphTooltip": 0,
  "id": 2,
  "links": [],
  "panels": [
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "be1w9io4ze7eod"
      },
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "thresholds"
          },
          "fieldMinMax": false,
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 80
              }
            ]
          }
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 6,
        "y": 0
      },
      "id": 3,
      "options": {
        "nestedObjects": [],
        "tables": [
          {
            "addRow": {
              "enabled": false,
              "permission": {
                "mode": "",
                "userRole": []
              },
              "request": {
                "datasource": "",
                "payload": {}
              }
            },
            "deleteRow": {
              "enabled": false,
              "permission": {
                "mode": "",
                "userRole": []
              },
              "request": {
                "datasource": "",
                "payload": {}
              }
            },
            "expanded": false,
            "items": [
              {
                "aggregation": "none",
                "appearance": {
                  "alignment": "center",
                  "background": {
                    "applyToRow": false
                  },
                  "colors": {},
                  "header": {
                    "backgroundColor": "#3274D9",
                    "fontSize": "lg"
                  },
                  "width": {
                    "auto": false,
                    "min": 20,
                    "value": 100
                  },
                  "wrap": true
                },
                "edit": {
                  "editor": {
                    "type": "string"
                  },
                  "enabled": false,
                  "permission": {
                    "mode": "",
                    "userRole": []
                  }
                },
                "enabled": true,
                "field": {
                  "name": "id",
                  "source": "A"
                },
                "filter": {
                  "enabled": true,
                  "mode": "client",
                  "variable": ""
                },
                "footer": [],
                "group": false,
                "label": "Id",
                "newRowEdit": {
                  "editor": {
                    "type": "string"
                  },
                  "enabled": false
                },
                "objectId": "",
                "pin": "",
                "preformattedStyle": false,
                "scale": "auto",
                "sort": {
                  "descFirst": false,
                  "enabled": false
                },
                "type": "auto"
              },
              {
                "aggregation": "none",
                "appearance": {
                  "alignment": "center",
                  "background": {
                    "applyToRow": false
                  },
                  "colors": {},
                  "header": {
                    "backgroundColor": "#3274D9",
                    "fontSize": "lg"
                  },
                  "width": {
                    "auto": true,
                    "min": 20,
                    "value": 100
                  },
                  "wrap": true
                },
                "edit": {
                  "editor": {
                    "type": "string"
                  },
                  "enabled": false,
                  "permission": {
                    "mode": "",
                    "userRole": []
                  }
                },
                "enabled": true,
                "field": {
                  "name": "nombre",
                  "source": "A"
                },
                "filter": {
                  "enabled": false,
                  "mode": "client",
                  "variable": ""
                },
                "footer": [],
                "group": false,
                "label": "Nombre",
                "newRowEdit": {
                  "editor": {
                    "type": "string"
                  },
                  "enabled": false
                },
                "objectId": "",
                "pin": "",
                "preformattedStyle": false,
                "scale": "auto",
                "sort": {
                  "descFirst": false,
                  "enabled": false
                },
                "type": "auto"
              },
              {
                "aggregation": "none",
                "appearance": {
                  "alignment": "center",
                  "background": {
                    "applyToRow": false
                  },
                  "colors": {},
                  "header": {
                    "backgroundColor": "#3274D9",
                    "fontSize": "lg"
                  },
                  "width": {
                    "auto": true,
                    "min": 20,
                    "value": 100
                  },
                  "wrap": true
                },
                "edit": {
                  "editor": {
                    "type": "string"
                  },
                  "enabled": false,
                  "permission": {
                    "mode": "",
                    "userRole": []
                  }
                },
                "enabled": true,
                "field": {
                  "name": "descripcion",
                  "source": "A"
                },
                "filter": {
                  "enabled": false,
                  "mode": "client",
                  "variable": ""
                },
                "footer": [],
                "group": false,
                "label": "Descripción",
                "newRowEdit": {
                  "editor": {
                    "type": "string"
                  },
                  "enabled": false
                },
                "objectId": "",
                "pin": "",
                "preformattedStyle": false,
                "scale": "auto",
                "sort": {
                  "descFirst": false,
                  "enabled": false
                },
                "type": "auto"
              }
            ],
            "name": "Modelos",
            "pagination": {
              "defaultPageSize": 10,
              "enabled": true,
              "mode": "client"
            },
            "showHeader": true,
            "update": {
              "datasource": "",
              "payload": {}
            }
          }
        ],
        "toolbar": {
          "export": false
        }
      },
      "pluginVersion": "1.9.0",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "be1w9io4ze7eod"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT \r\n  id,\r\n  nombre,\r\n  descripcion\r\nFROM\r\n  grafana_ml_model_index; ",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-table-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "be1w9io4ze7eod"
      },
      "gridPos": {
        "h": 18,
        "w": 20,
        "x": 2,
        "y": 8
      },
      "id": 1,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fields = context.panel.data.series[0].fields;\n\n  // Extraer valores de la consulta SQL\n  const caracteristicas = fields.find(field => field.name === 'caracteristica').values;\n  const nodos_izquierdos = fields.find(field => field.name === 'nodo_izquierdo').values;\n  const nodos_derechos = fields.find(field => field.name === 'nodo_derecho').values;\n  const umbrales = fields.find(field => field.name === 'umbral').values;\n  const valores_prediccion = fields.find(field => field.name === 'valor_prediccion').values;\n  const arboles_ids = fields.find(field => field.name === 'modelo_id').values; // Identificador del árbol\n  const nodos_ids = fields.find(field => field.name === 'nodo_id').values; // Identificador del nodo\n\n  // Obtener valor de la variable para el filtro\n  let mode = context.grafana.replaceVariables('${Visualizaciones_Arboles_Decision}'); // Variable dinámica\n\n  // Obtener el valor de la variable para el modo\n  let theme = context.grafana.replaceVariables('${Modo_Visualizacion_Arbol}'); // Variable dinámica que define el modo (claro u oscuro)\n\n  // Obtener el valor de la variable para el tamaño\n  let tamanno = context.grafana.replaceVariables('${Tamanno_Etiqueta_Arbol_Decision}'); // Variable dinámica que define el tamaño de las etiquetas\n\n  // Definir los tamaños de las etiquetas\n  let fontSize;\n  if (tamanno === \"Pequeño\") {\n    fontSize = 12;\n  } else if (tamanno === \"Mediano\") {\n    fontSize = 14;\n  } else if (tamanno === \"Grande\") {\n    fontSize = 18;\n  }\n\n  // Obtener el valor de la variable para el grosor\n  let grosor = context.grafana.replaceVariables('${Grosor_Arista_Arbol_Decision}'); // Variable dinámica que define el grosor de las aristas\n\n  // Definir el grosor de las aristas\n  let width;\n  if (grosor === \"Fino\") {\n    width = 2;\n  } else if (grosor === \"Grueso\") {\n    width = 5;\n  }\n\n  // Lógica de selección según el valor del filtro\n  if (mode === \"Horizontal\") {\n    // Lógica para el primer panel\n    option = getPanelOption1(caracteristicas, nodos_izquierdos, nodos_derechos, umbrales, valores_prediccion, nodos_ids, theme, fontSize, width);\n  } else if (mode === \"Vertical\") {\n    // Lógica para el segundo panel\n    option = getPanelOption2(caracteristicas, nodos_izquierdos, nodos_derechos, umbrales, valores_prediccion, nodos_ids, theme, fontSize, width);\n  } else if (mode === \"Circular\") {\n    // Lógica para el tercer panel\n    option = getPanelOption3(caracteristicas, nodos_izquierdos, nodos_derechos, umbrales, valores_prediccion, nodos_ids, theme, fontSize, width);\n  } else if (mode === \"Doble\") {\n    // Lógica para el cuarto panel\n    option = getPanelOption4(caracteristicas, nodos_izquierdos, nodos_derechos, umbrales, valores_prediccion, arboles_ids, nodos_ids, theme, fontSize, width);\n  } else {\n    // Si el valor no coincide con ninguno, muestra un gráfico vacío o un mensaje\n    option = {\n      graphic: [\n        {\n          type: 'text',\n          left: 'center', // Posición fija en la esquina superior izquierda\n          top: '45%', // Posición fija en la esquina superior izquierda\n          style: {\n            text: 'Visualización no disponible', // Título personalizado\n            fontSize: 45,\n            fontWeight: 'bold',\n            fill: theme === 'Oscuro' ? 'white' : 'red', // Ajuste según el tema\n          },\n        },\n      ],\n      backgroundColor: theme === 'Oscuro' ? '#1F1F1F' : '#ffffff', // Fondo del gráfico\n    };\n  }\n\n  // Devuelve la configuración seleccionada\n  return option;\n}\n\n// Función para configurar el primer panel\nfunction getPanelOption1(caracteristicas, nodos_izquierdos, nodos_derechos, umbrales, valores_prediccion, nodos_ids, theme, fontSize, width) {\n  const nodos = caracteristicas.map((caracteristica, i) => ({\n    id: nodos_ids[i],\n    name: caracteristica,\n    leftChild: nodos_izquierdos[i],\n    rightChild: nodos_derechos[i],\n    threshold: umbrales[i],\n    prediction: valores_prediccion[i],\n    children: [],\n    label: nodos_izquierdos[i] !== null && nodos_derechos[i] !== null\n      ? `${caracteristica} <= ${umbrales[i].toFixed(2)}` // Solo nodos internos muestran la comparación\n      : `Clase = ${valores_prediccion[i]}`               // Nodos hoja muestran la clase predicha\n  }));\n\n  const idToNode = Object.fromEntries(nodos.map(node => [node.id, node]));\n\n  // Crear nodos etiquetas\n  const nodoTrue = {\n    id: 'nodoTrue',\n    name: 'True',\n    children: [],\n    label: 'True',\n    symbolSize: 0,\n    label: {\n      show: true,\n      position: 'middle',\n      formatter: () => 'True',\n      fontSize: fontSize,\n      color: 'green'\n    }\n  };\n\n  const nodoFalse = {\n    id: 'nodoFalse',\n    name: 'False',\n    children: [],\n    label: 'False',\n    symbolSize: 0,\n    label: {\n      show: true,\n      position: 'middle',\n      formatter: () => 'False',\n      fontSize: fontSize,\n      color: 'red'\n    }\n  };\n\n  // Obtener el nodo raíz y los hijos izquierdo y derecho\n  const nodoRaiz = idToNode[nodos_ids[0]];\n  const leftChild = idToNode[nodoRaiz.leftChild];\n  const rightChild = idToNode[nodoRaiz.rightChild];\n\n  // Conectar el nodo raíz con los nodos etiquetas\n  nodoRaiz.children.push(nodoTrue);\n  nodoRaiz.children.push(nodoFalse);\n\n  // Conectar los nodos etiquetas con los hijos reales\n  if (leftChild) nodoTrue.children.push(leftChild);\n  if (rightChild) nodoFalse.children.push(rightChild);\n\n  // Construcción de conexiones entre los demás nodos\n  nodos.forEach(nodo => {\n    if (nodo.leftChild !== undefined && nodo.id !== nodoRaiz.id) {\n      const leftNode = idToNode[nodo.leftChild];\n      if (leftNode) nodo.children.push(leftNode);\n    }\n    if (nodo.rightChild !== undefined && nodo.id !== nodoRaiz.id) {\n      const rightNode = idToNode[nodo.rightChild];\n      if (rightNode) nodo.children.push(rightNode);\n    }\n  });\n\n  const option = {\n    tooltip: {\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: params => {\n        const { name, data } = params;\n        if (data.children && data.children.length > 0) {\n          return `\n            <b>Característica:</b> ${name}<br>\n            <b>Umbral:</b> ${data.threshold.toFixed(2)}<br>\n          `;\n        } else {\n          return `<b>Clase:</b> ${data.prediction}`;\n        }\n      }\n    },\n    graphic: [\n      {\n        type: 'text',\n        left: 'center', // Posición fija en la esquina superior izquierda\n        top: '5%', // Posición fija en la esquina superior izquierda\n        style: {\n          text: 'Árbol de Decisión ( Horizontal )', // Título personalizado\n          fontSize: 20,\n          fontWeight: 'bold',\n          fill: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color del texto según el tema\n        },\n      },\n    ],\n    series: [\n      {\n        type: 'tree',\n        data: [nodoRaiz],\n        top: '1%',\n        left: '17%',\n        bottom: '1%',\n        right: '20%',\n        symbolSize: 7,\n        label: {\n          position: 'left',\n          verticalAlign: 'middle',\n          align: 'right',\n          fontSize: fontSize,\n          color: theme === 'Oscuro' ? '#E0E0E0' : undefined, // Color de las etiquetas\n          formatter: node => node.data.label\n        },\n        leaves: {\n          label: {\n            position: 'right',\n            verticalAlign: 'middle',\n            align: 'left',\n            fontSize: fontSize,\n            color: theme === 'Oscuro' ? '#E0E0E0' : undefined // Color de las hojas\n          }\n        },\n        emphasis: {\n          focus: 'descendant'\n        },\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#2E2E2E' : '#cccccc', // Color de las líneas del árbol\n          width: width,\n        },\n        itemStyle: {\n          color: theme === 'Oscuro' ? '#2E2E2E' : undefined, // Fondo de los nodos\n          borderColor: theme === 'Oscuro' ? '#E0E0E0' : undefined, // Borde de los nodos\n          borderWidth: 1,\n        },\n        expandAndCollapse: true,\n        animationDuration: 550,\n        animationDurationUpdate: 750,\n      }\n    ],\n    backgroundColor: theme === 'Oscuro' ? '#1F1F1F' : '#ffffff', // Fondo del gráfico\n  };\n  return option;\n}\n\n// Función para configurar el segundo panel\nfunction getPanelOption2(caracteristicas, nodos_izquierdos, nodos_derechos, umbrales, valores_prediccion, nodos_ids, theme, fontSize, width) {\n  const nodos = caracteristicas.map((caracteristica, i) => ({\n    id: nodos_ids[i],\n    name: caracteristica,\n    leftChild: nodos_izquierdos[i],\n    rightChild: nodos_derechos[i],\n    threshold: umbrales[i],\n    prediction: valores_prediccion[i],\n    children: [],\n    label: nodos_izquierdos[i] !== null && nodos_derechos[i] !== null\n      ? `${caracteristica} <= ${umbrales[i].toFixed(2)}` // Solo nodos internos muestran la comparación\n      : `Clase = ${valores_prediccion[i]}`               // Nodos hoja muestran la clase predicha\n  }));\n\n  const idToNode = Object.fromEntries(nodos.map(node => [node.id, node]));\n\n  // Crear nodos etiquetas\n  const nodoTrue = {\n    id: 'nodoTrue',\n    name: 'True',\n    children: [],\n    label: 'True',\n    symbolSize: 0,\n    label: {\n      show: true,\n      position: 'middle',\n      formatter: () => 'True',\n      fontSize: fontSize,\n      color: 'green'\n    }\n  };\n\n  const nodoFalse = {\n    id: 'nodoFalse',\n    name: 'False',\n    children: [],\n    label: 'False',\n    symbolSize: 0,\n    label: {\n      show: true,\n      position: 'middle',\n      formatter: () => 'False',\n      fontSize: fontSize,\n      color: 'red'\n    }\n  };\n\n  // Obtener el nodo raíz y los hijos izquierdo y derecho\n  const nodoRaiz = idToNode[nodos_ids[0]];\n  const leftChild = idToNode[nodoRaiz.leftChild];\n  const rightChild = idToNode[nodoRaiz.rightChild];\n\n  // Conectar el nodo raíz con los nodos etiquetas\n  nodoRaiz.children.push(nodoTrue);\n  nodoRaiz.children.push(nodoFalse);\n\n  // Conectar los nodos etiquetas con los hijos reales\n  if (leftChild) nodoTrue.children.push(leftChild);\n  if (rightChild) nodoFalse.children.push(rightChild);\n\n  // Construcción de conexiones entre los demás nodos\n  nodos.forEach(nodo => {\n    if (nodo.leftChild !== undefined && nodo.id !== nodoRaiz.id) {\n      const leftNode = idToNode[nodo.leftChild];\n      if (leftNode) nodo.children.push(leftNode);\n    }\n    if (nodo.rightChild !== undefined && nodo.id !== nodoRaiz.id) {\n      const rightNode = idToNode[nodo.rightChild];\n      if (rightNode) nodo.children.push(rightNode);\n    }\n  });\n\n  // Configuración del gráfico orientado de arriba hacia abajo\n  const option = {\n    tooltip: {\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: params => {\n        const { name, data } = params;\n        if (data.children && data.children.length > 0) {\n          return `\n            <b>Característica:</b> ${name}<br>\n            <b>Umbral:</b> ${data.threshold.toFixed(2)}<br>\n          `;\n        } else {\n          return `<b>Clase:</b> ${data.prediction}`;\n        }\n      }\n    },\n    graphic: [\n      {\n        type: 'text',\n        left: '2%', // Posición fija en la esquina superior izquierda\n        top: '5%', // Posición fija en la esquina superior izquierda\n        style: {\n          text: 'Árbol de Decisión ( Vertical )', // Título personalizado\n          fontSize: 20,\n          fontWeight: 'bold',\n          fill: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color del texto según el tema\n        },\n      },\n    ],\n    series: [\n      {\n        type: 'tree',\n        data: [nodoRaiz],\n        left: '2%',\n        right: '2%',\n        top: '8%',\n        bottom: '20%',\n        orient: 'vertical', // Orientación del árbol: de arriba hacia abajo\n        symbol: 'emptyCircle', // Cambiar si deseas otro estilo de nodo\n        label: {\n          position: 'top',\n          verticalAlign: 'middle',\n          align: 'center',\n          fontSize: fontSize,\n          color: theme === 'Oscuro' ? '#E0E0E0' : undefined, // Color de las etiquetas\n          formatter: node => node.data.label\n        },\n        leaves: {\n          label: {\n            position: 'bottom',\n            verticalAlign: 'middle',\n            align: 'center',\n            fontSize: fontSize,\n            color: theme === 'Oscuro' ? '#E0E0E0' : undefined // Color de las hojas\n          }\n        },\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#2E2E2E' : '#cccccc', // Color de las líneas del árbol\n          width: width,\n        },\n        itemStyle: {\n          color: theme === 'Oscuro' ? '#2E2E2E' : undefined, // Fondo de los nodos\n          borderColor: theme === 'Oscuro' ? '#E0E0E0' : undefined, // Borde de los nodos\n          borderWidth: 1,\n        },\n        expandAndCollapse: true,\n        animationDurationUpdate: 750\n      }\n    ],\n    backgroundColor: theme === 'Oscuro' ? '#1F1F1F' : '#ffffff', // Fondo del gráfico\n  };\n  return option;\n}\n\n// Función para configurar el tercer panel\nfunction getPanelOption3(caracteristicas, nodos_izquierdos, nodos_derechos, umbrales, valores_prediccion, nodos_ids, theme, fontSize, width) {\n  const nodos = caracteristicas.map((caracteristica, i) => ({\n    id: nodos_ids[i],\n    name: caracteristica,\n    leftChild: nodos_izquierdos[i],\n    rightChild: nodos_derechos[i],\n    threshold: umbrales[i],\n    prediction: valores_prediccion[i],\n    children: [],\n    label: nodos_izquierdos[i] !== null && nodos_derechos[i] !== null\n      ? `${caracteristica} <= ${umbrales[i].toFixed(2)}`\n      : `Clase = ${valores_prediccion[i]}` // Etiqueta para hojas\n  }));\n\n  const idToNode = Object.fromEntries(nodos.map(node => [node.id, node]));\n\n  // Crear nodos etiquetas\n  const nodoTrue = {\n    id: 'nodoTrue',\n    name: 'True',\n    children: [],\n    label: 'True',\n    symbolSize: 0,\n    label: {\n      show: true,\n      position: 'middle',\n      formatter: () => 'True',\n      fontSize: fontSize,\n      color: 'green'\n    }\n  };\n\n  const nodoFalse = {\n    id: 'nodoFalse',\n    name: 'False',\n    children: [],\n    label: 'False',\n    symbolSize: 0,\n    label: {\n      show: true,\n      position: 'middle',\n      formatter: () => 'False',\n      fontSize: fontSize,\n      color: 'red'\n    }\n  };\n\n  // Obtener el nodo raíz y los hijos izquierdo y derecho\n  const nodoRaiz = idToNode[nodos_ids[0]];\n  const leftChild = idToNode[nodoRaiz.leftChild];\n  const rightChild = idToNode[nodoRaiz.rightChild];\n\n  // Conectar el nodo raíz con los nodos etiquetas\n  nodoRaiz.children.push(nodoTrue);\n  nodoRaiz.children.push(nodoFalse);\n\n  // Conectar los nodos etiquetas con los hijos reales\n  if (leftChild) nodoTrue.children.push(leftChild);\n  if (rightChild) nodoFalse.children.push(rightChild);\n\n  // Construcción de conexiones entre los demás nodos\n  nodos.forEach(nodo => {\n    if (nodo.leftChild !== undefined && nodo.id !== nodoRaiz.id) {\n      const leftNode = idToNode[nodo.leftChild];\n      if (leftNode) nodo.children.push(leftNode);\n    }\n    if (nodo.rightChild !== undefined && nodo.id !== nodoRaiz.id) {\n      const rightNode = idToNode[nodo.rightChild];\n      if (rightNode) nodo.children.push(rightNode);\n    }\n  });\n\n  // Configuración del gráfico radial\n  const option = {\n    tooltip: {\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: params => {\n        const { name, data } = params;\n        if (data.children && data.children.length > 0) {\n          return `\n          <b>Característica:</b> ${name}<br>\n          <b>Umbral:</b> ${data.threshold.toFixed(2)}<br>\n        `;\n        } else {\n          return `<b>Clase:</b> ${data.prediction}`;\n        }\n      }\n    },\n    graphic: [\n      {\n        type: 'text',\n        left: 'center', // Posición fija en la esquina superior izquierda\n        top: '5%', // Posición fija en la esquina superior izquierda\n        style: {\n          text: 'Árbol de Decisión ( Circular )', // Título personalizado\n          fontSize: 20,\n          fontWeight: 'bold',\n          fill: theme === 'Oscuro' ? '#ffffff' : '#000000' // Color del texto según el tema\n        },\n      },\n    ],\n    series: [\n      {\n        type: 'tree',\n        data: [nodoRaiz],\n        top: '5%', // Aumentar este valor para más espacio vertical\n        bottom: '5%',\n        left: '5%', // Aumentar este valor para más espacio horizontal\n        right: '5%',\n        layout: 'radial', // Disposición radial\n        symbol: 'emptyCircle',\n        symbolSize: 10, // Incrementar el tamaño del símbolo para mejorar visibilidad\n        label: {\n          position: 'middle',\n          rotate: 0,\n          verticalAlign: 'middle',\n          align: 'center',\n          fontSize: fontSize,\n          color: theme === 'Oscuro' ? '#E0E0E0' : undefined, // Color de las etiquetas\n          formatter: node => node.data.label\n        },\n        leaves: {\n          label: {\n            position: 'middle',\n            rotate: 0,\n            verticalAlign: 'middle',\n            align: 'center',\n            fontSize: fontSize,\n            color: theme === 'Oscuro' ? '#E0E0E0' : undefined // Color de las hojas\n          }\n        },\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#2E2E2E' : '#cccccc', // Color de las líneas del árbol\n          width: width,\n        },\n        itemStyle: {\n          color: theme === 'Oscuro' ? '#2E2E2E' : undefined, // Fondo de los nodos\n          borderColor: theme === 'Oscuro' ? '#E0E0E0' : undefined, // Borde de los nodos\n          borderWidth: 1,\n        },\n        animationDurationUpdate: 750,\n        emphasis: {\n          focus: 'descendant'\n        },\n        roam: true, // Permite hacer zoom y desplazarse para observar mejor el diseño\n      }\n    ],\n    backgroundColor: theme === 'Oscuro' ? '#1F1F1F' : '#ffffff', // Fondo del gráfico\n  };\n  return option;\n}\n\n// Función para configurar el cuarto panel\nfunction getPanelOption4(caracteristicas, nodos_izquierdos, nodos_derechos, umbrales, valores_prediccion, arboles_ids, nodos_ids, theme, fontSize, width) {\n  // Agrupar nodos por árbol\n  const arboles = {};\n  for (let i = 0; i < caracteristicas.length; i++) {\n    const arbolId = arboles_ids[i];\n    if (!arboles[arbolId]) {\n      arboles[arbolId] = [];\n    }\n    if (arboles_ids[i] === arbolId) {\n      arboles[arbolId].push({\n        id: nodos_ids[i],\n        name: caracteristicas[i],\n        leftChild: nodos_izquierdos[i],\n        rightChild: nodos_derechos[i],\n        threshold: umbrales[i],\n        prediction: valores_prediccion[i],\n        children: [],\n        label: nodos_izquierdos[i] !== null && nodos_derechos[i] !== null\n          ? `${caracteristicas[i]} <= ${umbrales[i].toFixed(2)}`\n          : `Clase = ${valores_prediccion[i]}`\n      });\n    }\n  }\n\n  // Construir nodos para cada árbol\n  const opcionesArboles = Object.entries(arboles).map(([arbolId, nodos], index) => {\n    // Generar IDs únicos para cada nodo dentro del árbol\n    const idToNode = Object.fromEntries(nodos.map(node => [node.id, node]));\n    const nodoRaiz = nodos.find(node => arboles_ids[nodos_ids.indexOf(node.id)] === parseInt(arbolId));\n\n    // Crear nodos etiquetas\n    const nodoTrue = {\n      id: `nodoTrue_${arbolId}`,\n      name: 'True',\n      children: [],\n      label: 'True',\n      symbolSize: 0,\n      label: {\n        show: true,\n        position: 'middle',\n        formatter: () => 'True',\n        fontSize: fontSize,\n        color: 'green'\n      },\n      tooltip: { // Deshabilita el tooltip para este nodo\n        show: false\n      },\n      emphasis: {\n        focus: 'none', // Evitar el sobresalto\n        scale: false, // Evitar cambios de tamaño\n        itemStyle: {\n          opacity: 1 // Mantener el nodo visible\n        },\n        label: {\n          show: true // Mantener la etiqueta visible\n        }\n      },\n    };\n\n    const nodoFalse = {\n      id: `nodoFalse_${arbolId}`,\n      name: 'False',\n      children: [],\n      label: 'False',\n      symbolSize: 0,\n      label: {\n        show: true,\n        position: 'middle',\n        formatter: () => 'False',\n        fontSize: fontSize,\n        color: 'red'\n      },\n      tooltip: { // Deshabilita el tooltip para este nodo\n        show: false\n      },\n      emphasis: {\n        focus: 'none', // Evitar el sobresalto\n        scale: false, // Evitar cambios de tamaño\n        itemStyle: {\n          opacity: 1 // Mantener el nodo visible\n        },\n        label: {\n          show: true // Mantener la etiqueta visible\n        }\n      },\n    };\n\n    // Conectar el nodo raíz con los nodos etiquetas\n    nodoRaiz.children.push(nodoTrue);\n    nodoRaiz.children.push(nodoFalse);\n\n    // Conectar los nodos etiquetas con los hijos reales\n    const leftChild = idToNode[nodoRaiz.leftChild];\n    const rightChild = idToNode[nodoRaiz.rightChild];\n    if (leftChild) nodoTrue.children.push(leftChild);\n    if (rightChild) nodoFalse.children.push(rightChild);\n\n    // Conectar nodos restantes\n    nodos.forEach(nodo => {\n      if (nodo.leftChild !== undefined && nodo.id !== nodoRaiz.id) {\n        const leftNode = idToNode[nodo.leftChild];\n        if (leftNode) nodo.children.push(leftNode);\n      }\n      if (nodo.rightChild !== undefined && nodo.id !== nodoRaiz.id) {\n        const rightNode = idToNode[nodo.rightChild];\n        if (rightNode) nodo.children.push(rightNode);\n      }\n    });\n\n    // Configuración dinámica de posiciones\n    const left = `${20 + index * 50}%`;\n    const right = `${70 - index * 30}%`;\n\n    return {\n      type: 'tree',\n      name: `Modelo ${arbolId}`,\n      data: [nodoRaiz],\n      top: '10%',\n      left,\n      bottom: '10%',\n      right,\n      symbolSize: 7,\n      label: {\n        position: 'left',\n        verticalAlign: 'middle',\n        align: 'right',\n        fontSize: fontSize,\n        color: theme === 'Oscuro' ? '#E0E0E0' : undefined, // Color de las etiquetas\n        formatter: node => node.data.label\n      },\n      leaves: {\n        label: {\n          position: 'right',\n          verticalAlign: 'middle',\n          align: 'left',\n          fontSize: fontSize,\n          color: theme === 'Oscuro' ? '#E0E0E0' : undefined, // Color de las hojas\n        }\n      },\n      emphasis: {\n        focus: 'descendant'\n      },\n      lineStyle: {\n        color: theme === 'Oscuro' ? '#2E2E2E' : '#cccccc', // Color de las líneas del árbol\n        width: width,\n      },\n      itemStyle: {\n        color: theme === 'Oscuro' ? '#2E2E2E' : \"#5470C6\", // Fondo de los nodos\n        borderColor: theme === 'Oscuro' ? '#E0E0E0' : \"#5470C6\", // Borde de los nodos\n        borderWidth: 1,\n      },\n      expandAndCollapse: true,\n      animationDuration: 350,\n      animationDurationUpdate: 500\n    };\n  });\n\n  // Configuración final de ECharts\n  const option = {\n    tooltip: {\n      trigger: 'item',\n      triggerOn: 'mousemove',\n      formatter: params => {\n        const { name, data } = params;\n        if (data.children && data.children.length > 0) {\n          return `\n            <b>Característica:</b> ${name}<br>\n            <b>Umbral:</b> ${data.threshold?.toFixed(2) || 'N/A'}<br>\n          `;\n        } else {\n          return `<b>Clase:</b> ${data.prediction}`;\n        }\n      }\n    },\n    legend: {\n      top: '8%',\n      left: '5%',\n      orient: 'vertical',\n      data: opcionesArboles.map(op => ({\n        name: op.name,\n        icon: 'rectangle',\n        itemStyle: {\n          color: theme === 'Oscuro' ? '#2E2E2E' : \"#5470C6\", // Colores fijos para Modelos\n        },\n      })),\n      textStyle: {\n        fontSize: fontSize,\n        color: theme === 'Oscuro' ? '#E0E0E0' : '#000000', // Color del texto según el tema\n      },\n      backgroundColor: theme === 'Oscuro' ? '#2E2E2E' : '#ffffff', // Fondo de la leyenda\n      borderColor: theme === 'Oscuro' ? '#444444' : '#c23531', // Borde de la leyenda según el tema\n      borderWidth: 1, // Espesor del borde\n      padding: 10, // Espaciado interno\n      itemGap: 10 // Espaciado entre elementos\n    },\n    graphic: [\n      {\n        type: 'text',\n        left: 'center', // Posición fija en la esquina superior izquierda\n        top: '5%', // Posición fija en la esquina superior izquierda\n        style: {\n          text: 'Árbol de Decisión ( Doble )', // Título personalizado\n          fontSize: 20,\n          fontWeight: 'bold',\n          fill: theme === 'Oscuro' ? '#ffffff' : '#000000' // Color del texto según el tema\n        },\n      },\n    ],\n    series: opcionesArboles,\n    backgroundColor: theme === 'Oscuro' ? '#1F1F1F' : '#ffffff', // Fondo del gráfico\n  };\n\n  return option;\n}",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.4.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "be1w9io4ze7eod"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT\r\n  c.nombre AS caracteristica,\r\n  a.nodo_izquierdo,\r\n  a.nodo_derecho,\r\n  a.umbral,\r\n  vp.nombre_clase AS valor_prediccion,\r\n  a.modelo_id,\r\n  a.nodo_id\r\nFROM\r\n  grafana_ml_model_arbol_decision AS a\r\nLEFT JOIN\r\n  caracteristicas AS c ON a.caracteristica = c.caracteristica_id\r\nLEFT JOIN\r\n  valores_prediccion AS vp ON a.valor_prediccion = vp.prediccion_id\r\nWHERE\r\n  a.modelo_id IN ($Modelos_Arbol_Decision) \r\nORDER BY\r\n  a.nodo_id ASC;\r\n\r\n",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [
                  {
                    "name": "nodo_izquierdo",
                    "type": "functionParameter"
                  }
                ],
                "type": "function"
              },
              {
                "parameters": [
                  {
                    "name": "nodo_derecho",
                    "type": "functionParameter"
                  }
                ],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          },
          "table": "arbol_decision"
        }
      ],
      "type": "volkovlabs-echarts-panel"
    },
    {
      "datasource": {
        "default": true,
        "type": "grafana-postgresql-datasource",
        "uid": "be1w9io4ze7eod"
      },
      "gridPos": {
        "h": 21,
        "w": 20,
        "x": 2,
        "y": 26
      },
      "id": 2,
      "options": {
        "baidu": {
          "callback": "bmapReady",
          "key": ""
        },
        "editor": {
          "format": "auto"
        },
        "editorMode": "code",
        "gaode": {
          "key": "",
          "plugin": "AMap.Scale,AMap.ToolBar"
        },
        "getOption": "if (context.panel.data && context.panel.data.series.length > 0) {\n  const fields = context.panel.data.series[0].fields;\n\n  // Extraer valores de la consulta SQL\n  const antecedentes = fields.find(field => field.name === 'antecedente').values;\n  const consecuentes = fields.find(field => field.name === 'consecuente').values;\n  const soportes = fields.find(field => field.name === 'soporte').values;\n  const confianzas = fields.find(field => field.name === 'confianza').values;\n  const lifts = fields.find(field => field.name === 'lift').values;\n\n  // Obtener valor de la variable para el filtro\n  let mode = context.grafana.replaceVariables('${Visualizaciones_Reglas_Asociacion}'); // Variable dinámica\n\n  // Obtener el valor de la variable para el modo\n  let theme = context.grafana.replaceVariables('${Modo_Visualizacion_Regla}'); // Variable dinámica que define el modo (claro u oscuro)\n\n  // Obtener el valor de la variable para el grafo\n  let grafo = context.grafana.replaceVariables('${Grafo_Reglas_Asociacion}'); // Variable dinámica que define como mostrar el grafo\n\n  // Obtener el valor de la variable para el color de las reglas\n  let colorMode = context.grafana.replaceVariables('${Color_Reglas_Asociacion}');\n\n  // Función para generar colores aleatorios\n  function generateRandomColor() {\n    const letters = '0123456789ABCDEF';\n    let color = '#';\n    for (let i = 0; i < 6; i++) {\n      color += letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n  }\n\n  // Paletas de colores predefinidas\n  const palettes = {\n    Paleta1: [\n      '#0500FF', '#00F4FF', '#00FF05', '#FAFF00', '#FF0500', '#FF00FA', '#A703FF', '#035BFF', '#03FFA7', '#5BFF03',\n      '#FFA703', '#FF035B', '#F000FF', '#000FFF', '#00FFF0', '#0FFF00', '#FFF000', '#FF000F', '#FF0A74', '#950AFF',\n      '#0A74FF', '#0AFF95', '#74FF0A', '#FF950A', '#FF6552', '#FF52EC', '#6552FF', '#52ECFF', '#52FF65', '#ECFF52',\n    ],\n    Paleta2: [\n      '#1E8449', '#922B21', '#2471A3', '#7D6608', '#117A65', '#4A235A', '#B9770E', '#D4AC0D', '#34495E', '#145A32',\n      '#7B241C', '#2E86C1', '#A04000', '#1C2833', '#6E2C00', '#0B5345', '#4D5656', '#196F3D', '#7F8C8D', '#512E5F',\n      '#99A3A4', '#45B39D', '#85C1E9', '#76D7C4', '#F9E79F', '#D5F5E3', '#A3E4D7', '#A9CCE3', '#FAD7A0', '#ABB2B9',\n    ],\n    Paleta3: [\n      '#F4D03F', '#5DADE2', '#58D68D', '#AF7AC5', '#EB984E', '#EC7063', '#45B39D', '#5499C7', '#F5CBA7', '#E74C3C',\n      '#52BE80', '#7FB3D5', '#FAD7A0', '#DC7633', '#9B59B6', '#F39C12', '#28B463', '#2980B9', '#D35400', '#2874A6',\n      '#D98880', '#AAB7B8', '#F7DC6F', '#F5B041', '#BB8FCE', '#82E0AA', '#E59866', '#1ABC9C', '#E67E22', '#C0392B',\n    ],\n  };\n\n  // Función para asignar color a un nodo según el modo seleccionado\n  function assignColorToNode(nodeName, usedColors) {\n    let color;\n\n    // Normalizar el modo de color eliminando espacios en blanco\n    const normalizedColorMode = colorMode.replace(/\\s+/g, ''); // 'Paleta 1' → 'Paleta1'\n\n    // Asignar color según el modo seleccionado\n    if (normalizedColorMode === 'Aleatorio') {\n      color = generateRandomColor();\n\n      // Asegurarse de que el color no se haya usado antes\n      while (usedColors.has(color)) {\n        color = generateRandomColor();\n      }\n    } else if (palettes[normalizedColorMode]) {\n      // Seleccionar la paleta según el modo normalizado\n      const palette = palettes[normalizedColorMode];\n      const index = usedColors.size % palette.length; // Reinicia si supera el tamaño de la paleta\n      color = palette[index];\n    } else {\n      console.error('Modo de color inválido:', colorMode);\n      color = '#000000'; // Color por defecto en caso de error\n    }\n\n    // Añadir el color a la lista de colores usados\n    usedColors.add(color);\n\n    return color;\n  }\n\n  // Lógica de selección según el valor del filtro\n  if (mode === \"Grafo\") {\n    // Lógica para el primer panel\n    option = getPanelOption1(antecedentes, consecuentes, soportes, confianzas, lifts, theme, grafo);\n  } else if (mode === \"Matricial\") {\n    // Lógica para el segundo panel\n    option = getPanelOption2(antecedentes, consecuentes, soportes, confianzas, theme);\n  } else if (mode === \"Separadas\") {\n    // Lógica para el tercer panel\n    option = getPanelOption3(antecedentes, consecuentes, soportes, confianzas, lifts, theme, colorMode, palettes);\n  } else if (mode === \"3D\") {\n    // Lógica para el cuarto panel\n    option = getPanelOption4(antecedentes, consecuentes, soportes, confianzas, lifts, theme);\n  } else {\n    // Si el valor no coincide con ninguno, muestra un gráfico vacío o un mensaje\n    option = {\n      graphic: [\n        {\n          type: 'text',\n          left: 'center', // Posición fija en la esquina superior izquierda\n          top: '45%', // Posición fija en la esquina superior izquierda\n          style: {\n            text: 'Visualización no disponible', // Título personalizado\n            fontSize: 45,\n            fontWeight: 'bold',\n            fill: theme === 'Oscuro' ? 'white' : 'red', // Ajuste según el tema\n          },\n        },\n      ],\n      backgroundColor: theme === 'Oscuro' ? '#1F1F1F' : '#ffffff', // Fondo del gráfico\n    };\n  }\n\n  // Devuelve la configuración seleccionada\n  return option;\n}\n\n// Función para configurar el primer panel\nfunction getPanelOption1(antecedentes, consecuentes, soportes, confianzas, lifts, theme, grafo) {\n  const uniqueNodes = new Map(); // Para guardar nodos únicos\n  const links = []; // Para las conexiones\n  const nodosCompuestos = new Map(); // Para nodos compuestos\n  const usedColors = new Set(); // Para llevar un registro de colores usados\n\n  // Función para dividir un string en un arreglo de items\n  function parseItems(itemString) {\n    return itemString.split(',').map(item => item.trim());\n  }\n\n  // Crear nodos y enlaces\n  antecedentes.forEach((antecedente, index) => {\n    const consecuente = consecuentes[index];\n    const soporte = soportes[index];\n    const confianza = confianzas[index];\n    const lift = lifts[index];\n\n    // Dividir antecedentes y consecuentes en arreglos\n    const itemsAntecedente = parseItems(antecedente);\n    const itemsConsecuente = parseItems(consecuente);\n\n    // Crear nodos individuales y compuestos\n    itemsAntecedente.concat(itemsConsecuente).forEach(item => {\n      if (!uniqueNodes.has(item)) {\n        uniqueNodes.set(item, {\n          name: item,\n          itemStyle: { color: assignColorToNode(item, usedColors) },\n          symbolSize: 25,\n          label: {\n            show: true,\n            color: theme === 'Oscuro' ? '#E0E0E0' : '#000000'\n          },\n        });\n      }\n    });\n\n    // Crear nodos compuestos y sus relaciones\n    const nodoCompuesto = itemsAntecedente.join(', ');\n    if (!nodosCompuestos.has(nodoCompuesto)) {\n      nodosCompuestos.set(nodoCompuesto, {\n        name: nodoCompuesto,\n        itemStyle: { color: assignColorToNode(nodoCompuesto, usedColors) },\n        symbolSize: 30,\n        label: {\n          show: true,\n          color: theme === 'Oscuro' ? '#E0E0E0' : '#000000'\n        },\n      });\n      uniqueNodes.set(nodoCompuesto, nodosCompuestos.get(nodoCompuesto));\n    }\n\n    // Enlaces entre nodos individuales y el nodo compuesto (líneas discontinuas)\n    if (grafo === 'Ambas' || grafo === 'Relaciones Conjunción') {\n      itemsAntecedente.forEach(item => {\n        links.push({\n          source: item,\n          target: nodoCompuesto,\n          value: confianza,\n          support: soporte,\n          lift: lift,\n          lineStyle: {\n            color: theme === 'Oscuro' ? '#CCCCCC' : 'black',\n            curveness: 0.3,\n            width: 2,\n            opacity: 1,\n            type: 'dashed', // Línea discontinua para nodos en el mismo compuesto\n            emphasis: {\n              width: 5  // Grosor aumentado al hacer énfasis\n            }\n          },\n          emphasis: {\n            focus: 'adjacency'\n          },\n          tooltip: {\n            show: true, // Habilitar tooltip\n            formatter: params => {\n              return `Nodo conjunción: ${item}<br>`;\n            }\n          }\n        });\n      });\n    }\n\n    // Enlaces entre nodos compuestos y otros nodos (consecuentes) con flecha\n    if (grafo === 'Ambas' || grafo === 'Reglas Asociación') {\n      itemsConsecuente.forEach(item => {\n        links.push({\n          source: nodoCompuesto,\n          target: item,\n          value: confianza,\n          support: soporte,\n          lift: lift,\n          lineStyle: {\n            color: theme === 'Oscuro' ? '#54B6C6' : 'source',\n            curveness: 0.3,\n            width: 2,\n            opacity: 1,\n            type: 'solid', // Línea continua con flecha\n            emphasis: {\n              width: 5  // Grosor aumentado al hacer énfasis\n            }\n          },\n          emphasis: {\n            focus: 'adjacency'\n          },\n          symbol: ['none', 'arrow'],\n          symbolSize: [0, 13],\n        });\n      });\n    }\n    // Enlaces entre nodos individuales y otros nodos (consecuentes/antecedentes) con flecha\n    if (grafo === 'Ambas' || grafo === 'Reglas Asociación') {\n      itemsAntecedente.forEach(item => {\n        itemsConsecuente.forEach(conse => {\n          links.push({\n            source: item,\n            target: conse,\n            value: confianza,\n            support: soporte,\n            lift: lift,\n            lineStyle: {\n              color: theme === 'Oscuro' ? '#54B6C6' : 'source',\n              curveness: 0.3,\n              width: 2,\n              opacity: 1,\n              type: 'solid', // Línea continua con flecha\n              emphasis: {\n                width: 5  // Grosor aumentado al hacer énfasis\n              }\n            },\n            emphasis: {\n              focus: 'adjacency'\n            },\n            symbol: ['none', 'arrow'],\n            symbolSize: [0, 13],\n          });\n        });\n      });\n    }\n  });\n\n  // Categorías definidas para la leyenda\n  const categories = [];\n  if (grafo === 'Ambas' || grafo === 'Reglas Asociación') {\n    categories.push({ name: 'Reglas de asociación' });\n  }\n  if (grafo === 'Ambas' || grafo === 'Relaciones Conjunción') {\n    categories.push({ name: 'Relación de conjunción' });\n  }\n\n  // Ajuste de parámetros de diseño según la selección\n  let repulsion = 2000;\n  let edgeLength = [120, 200];\n  let topPosition = '20%';\n\n  if (grafo === 'Reglas Asociación') {\n    repulsion = 1500;\n    edgeLength = [100, 150];\n    topPosition = '20%';\n  } else if (grafo === 'Relaciones Conjunción') {\n    repulsion = 1450;\n    edgeLength = [110, 180];\n    topPosition = '20%';\n  }\n\n  // Configuración del grafo para ECharts\n  const option = {\n    tooltip: {\n      trigger: 'item',\n      formatter: function (params) {\n        if (params.dataType === 'edge') {\n          return `\n            <b>Confianza:</b> ${params.data.value.toFixed(2)}<br>\n            <b>Soporte:</b> ${params.data.support.toFixed(2)}<br>\n            <b>Lift:</b> ${params.data.lift.toFixed(2)}\n          `;\n        } else {\n          return `<b>Nodo:</b> ${params.data.name}`;\n        }\n      },\n    },\n    legend: {\n      type: 'plain', // Leyenda simple\n      selectedMode: false, // Sin interacción\n      textStyle: {\n        fontSize: 15,\n        color: theme === 'Oscuro' ? '#E0E0E0' : '#000000', // Color general del texto\n      },\n      itemGap: 20,\n      top: '13%',\n      data: categories.map(category => {\n        // Definir ícono y estilo solo para 'Relación de conjunción'\n        if (category.name === 'Relación de conjunción') {\n          return {\n            name: category.name,\n            icon: 'lin', // Ícono de línea\n            itemStyle: {\n              color: theme === 'Oscuro' ? '#CCCCCC' : 'black', // Color del ícono para esta categoría\n            },\n          };\n        }\n        return {\n          name: category.name,\n          icon: 'lin', // Usa el ícono por defecto para las demás categorías\n          itemStyle: {\n            color: theme === 'Oscuro' ? '#54B6C6' : undefined, // Color del ícono para esta categoría\n          },\n        };\n      }),\n    },\n    graphic: [\n      {\n        type: 'text',\n        left: '2%', // Posición fija en la esquina superior izquierda\n        top: '5%', // Posición fija en la esquina superior izquierda\n        style: {\n          text: 'Reglas de Asociación ( Grafo )', // Título personalizado\n          fontSize: 20,\n          fontWeight: 'bold',\n          fill: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color del texto\n        },\n      },\n    ],\n    series: [\n      {\n        type: 'graph',\n        layout: 'force',\n        data: Array.from(uniqueNodes.values()),\n        links: links,\n        categories: categories, // Asignación de categorías\n        roam: true,\n        label: {\n          position: 'right',\n          formatter: '{b}',\n        },\n        force: {\n          repulsion: repulsion,\n          edgeLength: edgeLength,\n          gravity: 0.05,\n        },\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#CCCCCC' : 'source',\n          curveness: 0.3,\n        },\n        emphasis: {\n          focus: 'adjacency',\n          lineStyle: {\n            width: 10,\n          },\n        },\n        top: topPosition,\n      },\n    ],\n    backgroundColor: theme === 'Oscuro' ? '#1F1F1F' : '#ffffff',\n  };\n\n  return option;\n}\n\n// Función para configurar el segundo panel\nfunction getPanelOption2(antecedentes, consecuentes, soportes, confianzas, theme) {\n  // Almacén para colores ya usados\n  const usedColors = new Set();\n\n  // Crear nodos únicos (tanto antecedentes como consecuentes)\n  const uniqueNodes = new Set([...antecedentes, ...consecuentes]);\n\n  // Crear nodos para la visualización\n  const nodes = [];\n\n  antecedentes.forEach((antecedente, index) => {\n    const consecuente = consecuentes[index];\n    const soporte = soportes[index];\n    const confianza = confianzas[index];\n\n    // Generar un color único para la regla\n    const ruleColor = assignColorToNode(`${antecedente} -> ${consecuente}`, usedColors);\n\n    // Crear un nodo para la regla completa\n    const ruleNode = {\n      name: `${antecedente} -> ${consecuente}`, // Regla como texto\n      value: [antecedente, consecuente], // Coordenadas X e Y (antecedente y consecuente)\n      symbolSize: 20, // Tamaño del nodo\n      itemStyle: { color: ruleColor }, // Color único del nodo\n      label: {\n        show: false\n      }\n    };\n\n    nodes.push(ruleNode);\n  });\n\n  // Configuración de la opción de ECharts\n  const option = {\n    tooltip: {\n      trigger: 'item',\n      formatter: function (params) {\n        return `\n          <b>Regla:</b> ${params.data.name}<br>\n          <b>Confianza:</b> ${confianzas[params.dataIndex].toFixed(2)}<br>\n          <b>Soporte:</b> ${soportes[params.dataIndex].toFixed(2)}\n        `;\n      }\n    },\n    xAxis: {\n      name: 'Antecedente',\n      type: 'category', // Eje categórico\n      data: Array.from(new Set(antecedentes)), // Usar valores únicos de antecedentes\n      nameLocation: 'middle',\n      nameGap: 40,\n      axisLine: {\n        show: true, // Mostrar línea principal del eje X\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#CCCCCC' : '#333' // Color de la línea del eje\n        }\n      },\n      axisLabel: {\n        interval: 0, // Mostrar todas las etiquetas\n      },\n      axisTick: {\n        show: true // Mostrar marcas de las divisiones en el eje\n      },\n      nameTextStyle: {\n        color: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color negro\n      },\n      splitLine: {\n        show: true, // Mostrar líneas de la cuadrícula\n        lineStyle: {\n          color: '#ddd' // Color de las líneas de la cuadrícula\n        }\n      }\n    },\n    yAxis: {\n      name: 'Consecuente',\n      type: 'category', // Eje categórico\n      data: Array.from(new Set(consecuentes)), // Usar valores únicos de consecuentes\n      nameLocation: 'middle',\n      nameGap: 130,\n      axisLine: {\n        show: true, // Mostrar línea principal del eje Y\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#CCCCCC' : '#333' // Color de la línea del eje\n        }\n      },\n      axisLabel: {\n        interval: 0, // Mostrar todas las etiquetas\n      },\n      axisTick: {\n        show: true // Mostrar marcas de las divisiones en el eje\n      },\n      nameTextStyle: {\n        color: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color negro\n      },\n      splitLine: {\n        show: true, // Mostrar líneas de la cuadrícula\n        lineStyle: {\n          color: '#ddd' // Color de las líneas de la cuadrícula\n        }\n      }\n    },\n    graphic: [\n      {\n        type: 'text',\n        left: 'center', // Posición fija en la esquina superior izquierda\n        top: '3%', // Posición fija en la esquina superior izquierda\n        style: {\n          text: 'Reglas de Asociación/ Gráfico Matricial/ Confianza y soporte', // Título personalizado\n          fontSize: 18,\n          fontWeight: 'bold',\n          fill: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color del texto\n        },\n      },\n    ],\n    series: [\n      {\n        type: 'scatter', // Cambiar a scatter ya que no hay enlaces\n        data: nodes,\n        label: {\n          show: true,\n          formatter: '{b}',\n          position: 'top'\n        },\n      }\n    ],\n    backgroundColor: theme === 'Oscuro' ? '#1F1F1F' : '#ffffff',\n  };\n  return option;\n}\n\n// Función para configurar el tercer panel\nfunction getPanelOption3(antecedentes, consecuentes, soportes, confianzas, lifts, theme, colorMode, palettes) {\n  // Mapa para asignar colores únicos a cada nodo\n  const nodeColors = new Map();\n  const usedColors = new Set(); // Para evitar duplicación de colores\n\n  // Función para obtener o asignar un color único a un nodo\n  function getColorForNode(nodeName) {\n    if (!nodeColors.has(nodeName)) {\n      // Normalizar el modo de color eliminando espacios en blanco\n      const normalizedColorMode = colorMode.replace(/\\s+/g, '');\n\n      let color;\n      if (normalizedColorMode === 'Aleatorio') {\n        // Generar color aleatorio y evitar duplicados\n        color = generateRandomColor();\n        while (usedColors.has(color)) {\n          color = generateRandomColor();\n        }\n      } else if (palettes[normalizedColorMode]) {\n        // Seleccionar la paleta correspondiente\n        const palette = palettes[normalizedColorMode];\n        const index = usedColors.size % palette.length; // Reinicia si supera el tamaño de la paleta\n        color = palette[index];\n      } else {\n        console.error('Modo de color inválido:', colorMode);\n        color = '#000000'; // Color por defecto en caso de error\n      }\n\n      // Asignar el color al nodo y marcarlo como usado\n      nodeColors.set(nodeName, color);\n      usedColors.add(color);\n    }\n\n    return nodeColors.get(nodeName);\n  }\n\n  // Crear un grafo para cada regla\n  const datas = [];\n  antecedentes.forEach((antecedente, index) => {\n    const consecuente = consecuentes[index];\n    const soporte = soportes[index];\n    const confianza = confianzas[index];\n    const lift = lifts[index];\n\n    // Tamaño dinámico basado en la confianza\n    const nodeSize = soporte * 60 + 25; // Tamaño base 25, escala por soporte\n    const linkWidth = confianza * 6 + 2;  // Grosor base 2, escala por confianza\n\n    // Crear nodos para el antecedente y el consecuente con colores consistentes\n    const nodes = [\n      {\n        name: antecedente,\n        itemStyle: { color: getColorForNode(antecedente) }, // Reutiliza el color único\n        symbolSize: nodeSize, // Tamaño dinámico del nodo\n        label: { show: true },\n      },\n      {\n        name: consecuente,\n        itemStyle: { color: getColorForNode(consecuente) }, // Reutiliza el color único\n        symbolSize: nodeSize, // Tamaño dinámico del nodo\n        label: { show: true },\n      },\n    ];\n\n    // Crear enlace entre los nodos\n    const links = [\n      {\n        source: antecedente,\n        target: consecuente,\n        value: confianza,\n        support: soporte,\n        lift: lift,\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#CCCCCC' : '#3498DB',\n          curveness: 0.3,\n          width: linkWidth, // Grosor dinámico de la línea\n        },\n        emphasis: {\n          focus: 'adjacency',\n        },\n        symbol: ['none', 'arrow'],\n        symbolSize: [0, 13],\n      },\n    ];\n\n    // Agregar grafo individual\n    datas.push({\n      nodes: nodes,\n      links: links,\n      confidence: confianza, // Usado para tamaño del grafo\n      support: soporte,\n      lift: lift,\n    });\n  });\n\n  // Calcular filas y columnas necesarias\n  const numRules = datas.length; // Número total de reglas\n  const columns = Math.ceil(Math.sqrt(numRules)); // Determinar columnas necesarias\n  const rows = Math.ceil(numRules / columns); // Determinar filas necesarias\n  const cellWidth = 98 / columns; // Ancho de cada celda en porcentaje\n  const cellHeight = 98 / rows; // Alto de cada celda en porcentaje\n\n  // Configuración final con varios grafos\n  const option = {\n    tooltip: {\n      trigger: 'item',\n      formatter: function (params) {\n        if (params.dataType === 'edge') {\n          return `\n            <b>Lift:</b> ${params.data.lift.toFixed(2)}\n          `;\n        } else {\n          return `<b>Nodo:</b> ${params.data.name}`;\n        }\n      },\n    },\n    graphic: [\n      {\n        type: 'text',\n        left: '1%', // Posición fija en la esquina superior izquierda\n        top: '1%', // Posición fija en la esquina superior izquierda\n        style: {\n          text: 'Reglas de Asociación/ Soporte tamaño nodo/ Confianza grosor arista/  Lift etiqueta', // Título personalizado\n          fontSize: 16,\n          fontWeight: 'bold',\n          fill: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color del texto\n        },\n      },\n    ],\n    series: datas.map((item, idx) => ({\n      type: 'graph',\n      layout: 'force',\n      animation: false,\n      data: item.nodes,\n      links: item.links,\n      left: `${(idx % columns) * cellWidth}%`, // Distribuir en columnas dinámicas\n      top: `${Math.floor(idx / columns) * cellHeight + 2}%`, // Distribuir en filas dinámicas\n      width: `${cellWidth}%`, // Ajustar ancho dinámico\n      height: `${cellHeight}%`, // Ajustar alto dinámico\n      force: {\n        repulsion: 300, // Espaciado entre nodos (constante)\n        edgeLength: [100, 100], // Longitud fija de enlaces\n        gravity: 0.1, // Ajuste de expansión general\n      },\n      emphasis: {\n        focus: 'adjacency',\n      },\n      lineStyle: {\n        curveness: 0.3,\n      },\n    })),\n    backgroundColor: theme === 'Oscuro' ? '#1F1F1F' : '#ffffff',\n  };\n  return option;\n}\n\n// Función para configurar el cuarto panel\nfunction getPanelOption4(antecedentes, consecuentes, soportes, confianzas, lifts, theme) {\n  // Almacén para colores ya usados\n  const usedColors = new Set();\n\n  // Generar datos para la visualización\n  const data3D = antecedentes.map((antecedente, index) => {\n    const consecuente = consecuentes[index];\n    const lift = lifts[index];\n    const confianza = confianzas[index];\n\n    // Asignar un color único a la regla\n    const ruleColor = assignColorToNode(`${antecedente} -> ${consecuente}`, usedColors);\n\n    // Escalar el tamaño del símbolo basado en la confianza\n    const minSize = 5;\n    const maxSize = 50;\n    const maxConfidence = Math.max(...confianzas);\n    const scaledSize = minSize + ((confianza / maxConfidence) * (maxSize - minSize));\n\n    return {\n      value: [antecedente, consecuente, lift], // Coordenadas X, Y, Z\n      symbolSize: scaledSize, // Tamaño proporcional a la confianza\n      itemStyle: {\n        color: ruleColor // Color único para cada regla\n      },\n      label: {\n        show: false,\n      }\n    };\n  });\n\n  // Configuración del gráfico 3D\n  const option = {\n    tooltip: {\n      trigger: 'item',\n      formatter: function (params) {\n        const index = params.dataIndex;\n        return `\n          <b>Regla:</b> ${antecedentes[index]} -> ${consecuentes[index]}<br>\n          <b>Confianza:</b> ${confianzas[index].toFixed(2)}<br>\n          <b>Soporte:</b> ${soportes[index].toFixed(2)}<br>\n        `;\n      }\n    },\n    xAxis3D: {\n      name: 'Antecedente',\n      type: 'category',\n      data: Array.from(new Set(antecedentes)), // Usar valores únicos de antecedentes\n      nameLocation: 'middle',\n      nameGap: 50,\n      axisLine: {\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#CCCCCC' : '#333' // Color de la línea del eje\n        }\n      },\n      axisLabel: {\n        interval: 0, // Mostrar todas las etiquetas\n      },\n      nameTextStyle: {\n        color: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color negro\n      },\n    },\n    yAxis3D: {\n      name: 'Consecuente',\n      type: 'category',\n      data: Array.from(new Set(consecuentes)), // Usar valores únicos de consecuentes\n      nameLocation: 'middle',\n      nameGap: 50,\n      axisLine: {\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#CCCCCC' : '#333' // Color de la línea del eje\n        }\n      },\n      axisLabel: {\n        interval: 0, // Mostrar todas las etiquetas\n      },\n      nameTextStyle: {\n        color: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color negro\n      },\n    },\n    zAxis3D: {\n      name: 'Lift',\n      type: 'value',\n      nameLocation: 'middle',\n      nameGap: 40,\n      nameTextStyle: {\n        color: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color negro\n      },\n      axisLine: {\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#CCCCCC' : '#333' // Color de la línea del eje\n        }\n      },\n    },\n    grid3D: {\n      boxWidth: 200,\n      boxDepth: 200,\n      boxHeight: 130,\n      viewControl: {\n        autoRotate: false,\n        center: [0, 0, 0],\n        targetCoord: [50, 50, 25],\n        distance: 400,\n      },\n      top: \"-30\",\n      axisPointer: {\n        lineStyle: {\n          color: theme === 'Oscuro' ? '#FF5733' : undefined, // Cambiar según el tema\n          width: 1,\n          type: 'solid',\n        }\n      }\n    },\n    graphic: [\n      {\n        type: 'text',\n        left: 'center', // Posición fija en la esquina superior izquierda\n        top: '5%', // Posición fija en la esquina superior izquierda\n        style: {\n          text: 'Reglas de Asociación/ Gráfico 3D/ Lift tercera dimensión/ Confianza tamaño', // Título personalizado\n          fontSize: 20,\n          fontWeight: 'bold',\n          fill: theme === 'Oscuro' ? '#ffffff' : '#000000', // Color del texto\n        },\n      },\n    ],\n    series: [\n      {\n        type: 'scatter3D',\n        data: data3D,\n        itemStyle: {\n          opacity: 0.8,\n        }\n      }\n    ],\n    backgroundColor: theme === 'Oscuro' ? '#1F1F1F' : '#ffffff',\n  };\n  return option;\n}",
        "google": {
          "callback": "gmapReady",
          "key": ""
        },
        "map": "none",
        "renderer": "canvas",
        "themeEditor": {
          "config": "{}",
          "name": "default"
        },
        "visualEditor": {
          "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
          "dataset": [],
          "series": []
        }
      },
      "pluginVersion": "6.4.1",
      "targets": [
        {
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "be1w9io4ze7eod"
          },
          "editorMode": "code",
          "format": "table",
          "rawQuery": true,
          "rawSql": "SELECT\r\n  r.antecedente,\r\n  r.consecuente,\r\n  r.soporte,\r\n  r.confianza,\r\n  r.lift\r\nFROM\r\n  grafana_ml_model_reglas_asociacion AS r\r\nWHERE \r\n  r.modelo_id = $Modelos_Reglas_Asociacion \r\nORDER BY\r\n  r.id ASC\r\nLIMIT\r\n  20;",
          "refId": "A",
          "sql": {
            "columns": [
              {
                "parameters": [],
                "type": "function"
              }
            ],
            "groupBy": [
              {
                "property": {
                  "type": "string"
                },
                "type": "groupBy"
              }
            ],
            "limit": 50
          }
        }
      ],
      "type": "volkovlabs-echarts-panel"
    }
  ],
  "refresh": "",
  "schemaVersion": 39,
  "tags": [],
  "templating": {
    "list": [
      {
        "current": {
          "selected": false,
          "text": "1",
          "value": "1"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "be1w9io4ze7eod"
        },
        "definition": "SELECT\n  i.id\nFROM\n  grafana_ml_model_index AS i\nINNER JOIN\n  grafana_ml_model_arbol_decision AS a ON i.id = a.modelo_id;\n\n\n  ",
        "hide": 0,
        "includeAll": false,
        "multi": true,
        "name": "Modelos_Arbol_Decision",
        "options": [],
        "query": "SELECT\n  i.id\nFROM\n  grafana_ml_model_index AS i\nINNER JOIN\n  grafana_ml_model_arbol_decision AS a ON i.id = a.modelo_id;\n\n\n  ",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 3,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "Vertical",
          "value": "Vertical"
        },
        "hide": 0,
        "includeAll": false,
        "multi": false,
        "name": "Visualizaciones_Arboles_Decision",
        "options": [
          {
            "selected": false,
            "text": "Horizontal",
            "value": "Horizontal"
          },
          {
            "selected": true,
            "text": "Vertical",
            "value": "Vertical"
          },
          {
            "selected": false,
            "text": "Circular",
            "value": "Circular"
          },
          {
            "selected": false,
            "text": "Doble",
            "value": "Doble"
          }
        ],
        "query": "Horizontal, Vertical, Circular, Doble",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Claro",
          "value": "Claro"
        },
        "hide": 0,
        "includeAll": false,
        "multi": false,
        "name": "Modo_Visualizacion_Arbol",
        "options": [
          {
            "selected": true,
            "text": "Claro",
            "value": "Claro"
          },
          {
            "selected": false,
            "text": "Oscuro",
            "value": "Oscuro"
          }
        ],
        "query": "Claro, Oscuro",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "2",
          "value": "2"
        },
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "be1w9io4ze7eod"
        },
        "definition": "SELECT\n  i.id\nFROM\n  grafana_ml_model_index AS i\nINNER JOIN\n  grafana_ml_model_reglas_asociacion AS r ON i.id = r.modelo_id;\n\n  ",
        "hide": 0,
        "includeAll": false,
        "multi": false,
        "name": "Modelos_Reglas_Asociacion",
        "options": [],
        "query": "SELECT\n  i.id\nFROM\n  grafana_ml_model_index AS i\nINNER JOIN\n  grafana_ml_model_reglas_asociacion AS r ON i.id = r.modelo_id;\n\n  ",
        "refresh": 1,
        "regex": "",
        "skipUrlSync": false,
        "sort": 3,
        "type": "query"
      },
      {
        "current": {
          "selected": false,
          "text": "Grafo",
          "value": "Grafo"
        },
        "hide": 0,
        "includeAll": false,
        "multi": false,
        "name": "Visualizaciones_Reglas_Asociacion",
        "options": [
          {
            "selected": true,
            "text": "Grafo",
            "value": "Grafo"
          },
          {
            "selected": false,
            "text": "Matricial",
            "value": "Matricial"
          },
          {
            "selected": false,
            "text": "Separadas",
            "value": "Separadas"
          },
          {
            "selected": false,
            "text": "3D",
            "value": "3D"
          }
        ],
        "query": "Grafo, Matricial, Separadas, 3D",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Claro",
          "value": "Claro"
        },
        "hide": 0,
        "includeAll": false,
        "multi": false,
        "name": "Modo_Visualizacion_Regla",
        "options": [
          {
            "selected": true,
            "text": "Claro",
            "value": "Claro"
          },
          {
            "selected": false,
            "text": "Oscuro",
            "value": "Oscuro"
          }
        ],
        "query": "Claro, Oscuro",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Pequeño",
          "value": "Pequeño"
        },
        "hide": 0,
        "includeAll": false,
        "label": "Tamaño_Etiqueta_Arbol_Decision",
        "multi": false,
        "name": "Tamanno_Etiqueta_Arbol_Decision",
        "options": [
          {
            "selected": true,
            "text": "Pequeño",
            "value": "Pequeño"
          },
          {
            "selected": false,
            "text": "Mediano",
            "value": "Mediano"
          },
          {
            "selected": false,
            "text": "Grande",
            "value": "Grande"
          }
        ],
        "query": "Pequeño, Mediano, Grande",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Fino",
          "value": "Fino"
        },
        "hide": 0,
        "includeAll": false,
        "label": "",
        "multi": false,
        "name": "Grosor_Arista_Arbol_Decision",
        "options": [
          {
            "selected": true,
            "text": "Fino",
            "value": "Fino"
          },
          {
            "selected": false,
            "text": "Grueso",
            "value": "Grueso"
          }
        ],
        "query": "Fino, Grueso",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Relaciones Conjunción",
          "value": "Relaciones Conjunción"
        },
        "hide": 0,
        "includeAll": false,
        "multi": false,
        "name": "Grafo_Reglas_Asociacion",
        "options": [
          {
            "selected": false,
            "text": "Ambas",
            "value": "Ambas"
          },
          {
            "selected": false,
            "text": "Reglas Asociación",
            "value": "Reglas Asociación"
          },
          {
            "selected": true,
            "text": "Relaciones Conjunción",
            "value": "Relaciones Conjunción"
          }
        ],
        "query": "Ambas, Reglas Asociación, Relaciones Conjunción ",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      },
      {
        "current": {
          "selected": false,
          "text": "Paleta 1",
          "value": "Paleta 1"
        },
        "hide": 0,
        "includeAll": false,
        "multi": false,
        "name": "Color_Reglas_Asociacion",
        "options": [
          {
            "selected": true,
            "text": "Paleta 1",
            "value": "Paleta 1"
          },
          {
            "selected": false,
            "text": "Paleta 2",
            "value": "Paleta 2"
          },
          {
            "selected": false,
            "text": "Paleta 3",
            "value": "Paleta 3"
          },
          {
            "selected": false,
            "text": "Aleatorio",
            "value": "Aleatorio"
          }
        ],
        "query": "Paleta 1, Paleta 2, Paleta 3, Aleatorio",
        "queryValue": "",
        "skipUrlSync": false,
        "type": "custom"
      }
    ]
  },
  "time": {
    "from": "now-6h",
    "to": "now"
  },
  "timepicker": {},
  "timezone": "browser",
  "title": "PP2",
  "uid": "ce1wc563124g0e",
  "version": 103,
  "weekStart": ""
}